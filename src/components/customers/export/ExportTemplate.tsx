'use client';

import { useState } from 'react';
import { Button } from '@/components/ui/button';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Alert, AlertDescription } from '@/components/ui/alert';
import { Checkbox } from '@/components/ui/checkbox';
import { Download, FileSpreadsheet, FileText, Settings } from 'lucide-react';
import { Company, Contract, Branch } from '@/types/customer';
import { formatDateForDisplay } from '@/lib/date-handler';

interface ExportTemplateProps {
  entityType: 'companies' | 'contracts' | 'contractsAdvanced' | 'branches';
  data: Company[] | Contract[] | Branch[];
  onClose?: () => void;
  // Add optional props for related data to enhance exports
  companies?: Company[];
  branches?: Branch[];
}

interface ExportConfig {
  includeArchived: boolean;
  dateRange?: {
    start: string;
    end: string;
  };
  selectedFields: string[];
  format: 'csv' | 'excel';
}

export function ExportTemplate({ entityType, data, onClose, companies, branches }: ExportTemplateProps) {
  const [isExporting, setIsExporting] = useState(false);
  
  // Debug logging for component props (simplified to prevent loops)
  console.log('üîç ExportTemplate props:', {
    entityType,
    dataLength: data.length,
    companiesLength: companies?.length || 0,
    branchesLength: branches?.length || 0,
    hasCompanies: !!companies,
    hasBranches: !!branches
  });
  const [exportConfig, setExportConfig] = useState<ExportConfig>({
    includeArchived: false,
    selectedFields: [],
    format: 'csv'
  });
  const [exportCompleted, setExportCompleted] = useState<string | null>(null);

  // Field configurations for different entity types
  const fieldConfigs = {
    companies: {
      title: 'ÿ™ÿµÿØŸäÿ± ÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑÿ¥ÿ±ŸÉÿßÿ™',
      description: 'ÿ™ÿµÿØŸäÿ± ÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑÿ¥ÿ±ŸÉÿßÿ™ ÿ•ŸÑŸâ Excel/CSV ŸÖÿπ ÿØÿπŸÖ ÿßŸÑŸÜÿµ ÿßŸÑÿπÿ±ÿ®Ÿä',
      availableFields: [
        { key: 'companyId', label: 'ŸÖÿπÿ±ŸÅ ÿßŸÑÿ¥ÿ±ŸÉÿ©', required: true },
        { key: 'companyName', label: 'ÿßÿ≥ŸÖ ÿßŸÑÿ¥ÿ±ŸÉÿ©', required: true },
        { key: 'email', label: 'ÿßŸÑÿ®ÿ±ŸäÿØ ÿßŸÑÿ•ŸÑŸÉÿ™ÿ±ŸàŸÜŸä', required: false },
        { key: 'phone', label: 'ÿ±ŸÇŸÖ ÿßŸÑŸáÿßÿ™ŸÅ', required: false },
        { key: 'address', label: 'ÿßŸÑÿπŸÜŸàÿßŸÜ', required: false },
        { key: 'city', label: 'ÿßŸÑŸÖÿØŸäŸÜÿ©', required: false },
        { key: 'contactPerson', label: 'ÿßŸÑÿ¥ÿÆÿµ ÿßŸÑŸÖÿ≥ÿ§ŸàŸÑ', required: false },
        { key: 'notes', label: 'ŸÖŸÑÿßÿ≠ÿ∏ÿßÿ™', required: false },
        { key: 'createdAt', label: 'ÿ™ÿßÿ±ŸäÿÆ ÿßŸÑÿ•ŸÜÿ¥ÿßÿ°', required: false },
        { key: 'updatedAt', label: 'ÿ™ÿßÿ±ŸäÿÆ ÿßŸÑÿ™ÿ≠ÿØŸäÿ´', required: false }
      ]
    },
    contracts: {
      title: 'ÿ™ÿµÿØŸäÿ± ÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑÿπŸÇŸàÿØ',
      description: 'ÿ™ÿµÿØŸäÿ± ÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑÿπŸÇŸàÿØ ŸÖÿπ ÿ™ŸÅÿßÿµŸäŸÑ ÿßŸÑÿÆÿØŸÖÿßÿ™ ŸàÿßŸÑÿ™Ÿàÿßÿ±ŸäÿÆ',
      availableFields: [
        { key: 'contractId', label: 'ŸÖÿπÿ±ŸÅ ÿßŸÑÿπŸÇÿØ', required: true },
        { key: 'companyId', label: 'ŸÖÿπÿ±ŸÅ ÿßŸÑÿ¥ÿ±ŸÉÿ©', required: true },
        { key: 'companyName', label: 'ÿßÿ≥ŸÖ ÿßŸÑÿ¥ÿ±ŸÉÿ©', required: false },
        { key: 'contractStartDate', label: 'ÿ™ÿßÿ±ŸäÿÆ ÿ®ÿØÿßŸäÿ© ÿßŸÑÿπŸÇÿØ', required: true },
        { key: 'contractEndDate', label: 'ÿ™ÿßÿ±ŸäÿÆ ÿßŸÜÿ™Ÿáÿßÿ° ÿßŸÑÿπŸÇÿØ', required: true },
        { key: 'contractPeriodMonths', label: 'ŸÖÿØÿ© ÿßŸÑÿπŸÇÿØ (ÿ®ÿßŸÑÿ£ÿ¥Ÿáÿ±)', required: false },
        { key: 'regularVisitsPerYear', label: 'ÿπÿØÿØ ÿßŸÑÿ≤Ÿäÿßÿ±ÿßÿ™ ÿßŸÑÿπÿßÿØŸäÿ© ÿ≥ŸÜŸàŸäÿßŸã', required: false },
        { key: 'emergencyVisitsPerYear', label: 'ÿπÿØÿØ ÿßŸÑÿ≤Ÿäÿßÿ±ÿßÿ™ ÿßŸÑÿ∑ÿßÿ±ÿ¶ÿ© ÿ≥ŸÜŸàŸäÿßŸã', required: false },
        { key: 'contractValue', label: 'ŸÇŸäŸÖÿ© ÿßŸÑÿπŸÇÿØ', required: false },
        { key: 'fireExtinguisherMaintenance', label: 'ÿµŸäÿßŸÜÿ© ÿßŸÑÿ∑ŸÅÿßŸäÿßÿ™', required: false },
        { key: 'alarmSystemMaintenance', label: 'ÿµŸäÿßŸÜÿ© ŸÜÿ∏ÿßŸÖ ÿßŸÑÿ•ŸÜÿ∞ÿßÿ±', required: false },
        { key: 'fireSuppressionMaintenance', label: 'ÿµŸäÿßŸÜÿ© ŸÜÿ∏ÿßŸÖ ÿßŸÑÿ•ÿ∑ŸÅÿßÿ°', required: false },
        { key: 'gasFireSuppression', label: 'ŸÜÿ∏ÿßŸÖ ÿßŸÑÿ•ÿ∑ŸÅÿßÿ° ÿ®ÿßŸÑÿ∫ÿßÿ≤', required: false },
        { key: 'foamFireSuppression', label: 'ŸÜÿ∏ÿßŸÖ ÿßŸÑÿ•ÿ∑ŸÅÿßÿ° ÿ®ÿßŸÑŸÅŸàŸÖ', required: false },
        { key: 'branchIds', label: 'ŸÖÿπÿ±ŸÅÿßÿ™ ÿßŸÑŸÅÿ±Ÿàÿπ', required: false },
        { key: 'branchNames', label: 'ÿ£ÿ≥ŸÖÿßÿ° ÿßŸÑŸÅÿ±Ÿàÿπ', required: false },
        { key: 'totalBranches', label: 'ÿπÿØÿØ ÿßŸÑŸÅÿ±Ÿàÿπ', required: false },
        { key: 'notes', label: 'ŸÖŸÑÿßÿ≠ÿ∏ÿßÿ™', required: false },
        { key: 'createdAt', label: 'ÿ™ÿßÿ±ŸäÿÆ ÿßŸÑÿ•ŸÜÿ¥ÿßÿ°', required: false }
      ]
    },
    contractsAdvanced: {
      title: 'ÿ™ÿµÿØŸäÿ± ÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑÿπŸÇŸàÿØ ÿßŸÑŸÖÿ™ŸÇÿØŸÖÿ©',
      description: 'ÿ™ÿµÿØŸäÿ± ÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑÿπŸÇŸàÿØ ÿßŸÑŸÖÿ™ŸÇÿØŸÖÿ© ŸÖÿπ ŸÖÿ¨ŸÖŸàÿπÿßÿ™ ÿßŸÑÿÆÿØŸÖÿßÿ™ ŸàÿßŸÑŸÅÿ±Ÿàÿπ',
      availableFields: [
        { key: 'contractId', label: 'ŸÖÿπÿ±ŸÅ ÿßŸÑÿπŸÇÿØ', required: true },
        { key: 'companyId', label: 'ŸÖÿπÿ±ŸÅ ÿßŸÑÿ¥ÿ±ŸÉÿ©', required: true },
        { key: 'contractStartDate', label: 'ÿ™ÿßÿ±ŸäÿÆ ÿ®ÿØÿßŸäÿ© ÿßŸÑÿπŸÇÿØ', required: true },
        { key: 'contractEndDate', label: 'ÿ™ÿßÿ±ŸäÿÆ ÿßŸÜÿ™Ÿáÿßÿ° ÿßŸÑÿπŸÇÿØ', required: false },
        { key: 'contractPeriodMonths', label: 'ŸÖÿØÿ© ÿßŸÑÿπŸÇÿØ (ÿ®ÿßŸÑÿ£ÿ¥Ÿáÿ±)', required: false },
        { key: 'contractValue', label: 'ŸÇŸäŸÖÿ© ÿßŸÑÿπŸÇÿØ', required: false },
        { key: 'serviceBatches', label: 'ŸÖÿ¨ŸÖŸàÿπÿßÿ™ ÿßŸÑÿÆÿØŸÖÿßÿ™', required: false },
        { key: 'totalBranches', label: 'ÿπÿØÿØ ÿßŸÑŸÅÿ±Ÿàÿπ', required: false },
        { key: 'totalServices', label: 'ÿπÿØÿØ ÿßŸÑÿÆÿØŸÖÿßÿ™', required: false },
        { key: 'notes', label: 'ŸÖŸÑÿßÿ≠ÿ∏ÿßÿ™ ÿßŸÑÿπŸÇÿØ', required: false },
        { key: 'createdAt', label: 'ÿ™ÿßÿ±ŸäÿÆ ÿßŸÑÿ•ŸÜÿ¥ÿßÿ°', required: false }
      ]
    },
    branches: {
      title: 'ÿ™ÿµÿØŸäÿ± ÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑŸÅÿ±Ÿàÿπ',
      description: 'ÿ™ÿµÿØŸäÿ± ÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑŸÅÿ±Ÿàÿπ ŸÖÿπ ÿ™ŸÅÿßÿµŸäŸÑ ÿßŸÑŸÖŸàÿßŸÇÿπ ŸàÿßŸÑÿπŸÇŸàÿØ',
      availableFields: [
        { key: 'branchId', label: 'ŸÖÿπÿ±ŸÅ ÿßŸÑŸÅÿ±ÿπ', required: true },
        { key: 'companyId', label: 'ŸÖÿπÿ±ŸÅ ÿßŸÑÿ¥ÿ±ŸÉÿ©', required: true },
        { key: 'contractIds', label: 'ŸÖÿπÿ±ŸÅÿßÿ™ ÿßŸÑÿπŸÇŸàÿØ', required: false },
        { key: 'city', label: 'ÿßŸÑŸÖÿØŸäŸÜÿ©', required: true },
        { key: 'location', label: 'ÿßŸÑŸÖŸàŸÇÿπ', required: true },
        { key: 'branchName', label: 'ÿßÿ≥ŸÖ ÿßŸÑŸÅÿ±ÿπ', required: true },
        { key: 'address', label: 'ÿßŸÑÿπŸÜŸàÿßŸÜ ÿßŸÑÿ™ŸÅÿµŸäŸÑŸä', required: false },
        { key: 'contactPerson', label: 'ÿßŸÑÿ¥ÿÆÿµ ÿßŸÑŸÖÿ≥ÿ§ŸàŸÑ', required: false },
        { key: 'contactPhone', label: 'Ÿáÿßÿ™ŸÅ ÿßŸÑÿ™ŸàÿßÿµŸÑ', required: false },
        { key: 'teamMember', label: 'ŸÅÿ±ŸäŸÇ ÿßŸÑÿπŸÖŸÑ ÿßŸÑŸÖÿÆÿ™ÿµ', required: false },
        { key: 'notes', label: 'ŸÖŸÑÿßÿ≠ÿ∏ÿßÿ™', required: false },
        { key: 'createdAt', label: 'ÿ™ÿßÿ±ŸäÿÆ ÿßŸÑÿ•ŸÜÿ¥ÿßÿ°', required: false }
      ]
    }
  };

  const currentConfig = fieldConfigs[entityType];

  // Initialize selected fields with required fields
  useState(() => {
    const requiredFields = currentConfig.availableFields
      .filter(field => field.required)
      .map(field => field.key);
    setExportConfig(prev => ({
      ...prev,
      selectedFields: requiredFields
    }));
  });

  const handleFieldToggle = (fieldKey: string, checked: boolean) => {
    setExportConfig(prev => ({
      ...prev,
      selectedFields: checked
        ? [...prev.selectedFields, fieldKey]
        : prev.selectedFields.filter(key => key !== fieldKey)
    }));
  };

  const formatFieldValue = (item: Company | Contract | Branch, fieldKey: string): string => {
    // Debug logging for all field processing (simplified to prevent loops)
    if (entityType === 'contracts') {
      const contract = item as Contract;
      console.log('üîç formatFieldValue called:', {
        fieldKey,
        fieldKeyType: typeof fieldKey,
        entityType,
        contractId: contract.contractId,
        companyId: contract.companyId
      });
    }

    // Handle computed fields for contracts first (before checking direct field values)
    if (entityType === 'contracts') {
      // Handle company name for contracts
      if (fieldKey === 'companyName') {
        const contract = item as Contract;
        console.log('üîç Company name lookup:', {
          contractId: contract.contractId,
          companyId: contract.companyId,
          companiesCount: companies?.length || 0,
          foundCompany: companies?.find(c => c.companyId === contract.companyId)?.companyName || 'Not found'
        });
        if (companies) {
          const company = companies.find(c => c.companyId === contract.companyId);
          return company?.companyName || '';
        }
        return '';
      }

      // Handle branch IDs for contracts
      if (fieldKey === 'branchIds') {
        const contract = item as Contract;
        console.log('üîç Branch IDs lookup:', {
          contractId: contract.contractId,
          hasServiceBatches: !!contract.serviceBatches,
          serviceBatchesCount: contract.serviceBatches?.length || 0,
          branchesCount: branches?.length || 0
        });
        if (contract.serviceBatches && branches) {
          const allBranchIds = new Set<string>();
          contract.serviceBatches.forEach(batch => {
            batch.branchIds?.forEach(branchId => allBranchIds.add(branchId));
          });
          const result = Array.from(allBranchIds).join(',');
          console.log('üîç Branch IDs result:', result);
          return result;
        }
        return '';
      }

      // Handle branch names for contracts
      if (fieldKey === 'branchNames') {
        const contract = item as Contract;
        if (contract.serviceBatches && branches) {
          const allBranchIds = new Set<string>();
          contract.serviceBatches.forEach(batch => {
            batch.branchIds?.forEach(branchId => allBranchIds.add(branchId));
          });
          const branchNames = Array.from(allBranchIds).map(branchId => {
            const branch = branches.find(b => b.branchId === branchId);
            return branch?.branchName || branchId;
          });
          return branchNames.join(',');
        }
        return '';
      }

      // Handle total branches for contracts
      if (fieldKey === 'totalBranches') {
        const contract = item as Contract;
        if (contract.serviceBatches) {
          const allBranchIds = new Set<string>();
          contract.serviceBatches.forEach(batch => {
            batch.branchIds?.forEach(branchId => allBranchIds.add(branchId));
          });
          return allBranchIds.size.toString();
        }
        return '0';
      }
    }

    const value = (item as unknown as Record<string, unknown>)[fieldKey];
    
    // Debug logging for contract exports to see what fields are being processed
    if (entityType === 'contracts') {
      console.log('üîç Field processing:', {
        fieldKey,
        value,
        valueType: typeof value,
        hasValue: value !== null && value !== undefined
      });
    }

    // Debug logging for contract exports
    if (entityType === 'contracts' && fieldKey === 'contractId') {
      const contract = item as Contract;
      console.log('üîç Processing contract:', {
        contractId: contract.contractId,
        companyId: contract.companyId,
        hasServiceBatches: !!contract.serviceBatches,
        serviceBatchesLength: contract.serviceBatches?.length || 0,
        companiesCount: companies?.length || 0,
        branchesCount: branches?.length || 0
      });
    }

    if (value === null || value === undefined) {
      return '';
    }

    // Handle boolean values for services
    if (typeof value === 'boolean') {
      return value ? 'ŸÜÿπŸÖ' : 'ŸÑÿß';
    }

    // Handle array values (like contractIds)
    if (Array.isArray(value)) {
      return value.join(',');
    }



    // Handle serviceBatches for advanced contracts
    if (fieldKey === 'serviceBatches' && Array.isArray(value)) {
      return value.map((batch: any) => {
        const services = Object.entries(batch.services || {})
          .filter(([_, enabled]) => enabled)
          .map(([service, _]) => service)
          .join(',');
        return `${batch.branchIds?.join(',') || ''}:${services}`;
      }).join(';');
    }

    // Handle totalBranches calculation for advanced contracts
    if (fieldKey === 'totalBranches' && entityType === 'contractsAdvanced') {
      const contract = item as Contract;
      if (contract.serviceBatches) {
        const allBranchIds = new Set<string>();
        contract.serviceBatches.forEach(batch => {
          batch.branchIds?.forEach(branchId => allBranchIds.add(branchId));
        });
        return allBranchIds.size.toString();
      }
      return '0';
    }

    // Handle totalServices calculation for advanced contracts
    if (fieldKey === 'totalServices' && entityType === 'contractsAdvanced') {
      const contract = item as Contract;
      if (contract.serviceBatches) {
        const allServices = new Set<string>();
        contract.serviceBatches.forEach(batch => {
          Object.entries(batch.services || {}).forEach(([service, enabled]) => {
            if (enabled) allServices.add(service);
          });
        });
        return allServices.size.toString();
      }
      return '0';
    }

    // Handle date formatting
    if (fieldKey.includes('Date') || fieldKey.includes('At')) {
      return formatDateForDisplay(value as string);
    }

    return String(value);
  };

  const generateComprehensiveExport = () => {
    setIsExporting(true);

    try {
      // Filter data based on configuration
      const filteredData = exportConfig.includeArchived
        ? data
        : data.filter((item) => !(item as unknown as Record<string, unknown>).isArchived);

      if (filteredData.length === 0) {
        alert('ŸÑÿß ÿ™Ÿàÿ¨ÿØ ÿ®ŸäÿßŸÜÿßÿ™ ŸÑŸÑÿ™ÿµÿØŸäÿ±');
        setIsExporting(false);
        return;
      }

      // Create Excel-compatible CSV content with UTF-8 BOM
      const BOM = '\uFEFF';

      let content = BOM;

      // Add title and export info
      content += `${currentConfig.title}\n`;
      content += `ÿ™ÿßÿ±ŸäÿÆ ÿßŸÑÿ™ÿµÿØŸäÿ±: ${formatDateForDisplay(new Date().toISOString())}\n`;
      content += `ÿπÿØÿØ ÿßŸÑÿ≥ÿ¨ŸÑÿßÿ™: ${filteredData.length}\n\n`;

      // Get headers
      const headers = exportConfig.selectedFields.map(fieldKey => {
        const field = currentConfig.availableFields.find(f => f.key === fieldKey);
        return field?.label || fieldKey;
      });

      content += headers.join(',') + '\n';

      // Debug logging for selected fields
      console.log('üîç Export configuration:');
      console.log('  - selectedFields:', exportConfig.selectedFields);
      console.log('  - totalDataItems:', filteredData.length);
      console.log('  - selectedFieldsDetails:');
      exportConfig.selectedFields.forEach((fieldKey, index) => {
        console.log(`    ${index + 1}. fieldKey: "${fieldKey}"`);
        console.log(`       type: ${typeof fieldKey}`);
        console.log(`       length: ${fieldKey.length}`);
        console.log(`       charCodes: [${Array.from(fieldKey).map(c => c.charCodeAt(0)).join(', ')}]`);
      });

      // Add data rows
      filteredData.forEach((item) => {
        const row = exportConfig.selectedFields.map(fieldKey => {
          const value = formatFieldValue(item, fieldKey);
          return `"${value.replace(/"/g, '""')}"`;
        });
        content += row.join(',') + '\n';
      });

      const blob = new Blob([content], { type: 'text/csv;charset=utf-8;' });
      const link = document.createElement('a');
      const url = URL.createObjectURL(blob);

      const timestamp = new Date().toISOString().split('T')[0];
      link.setAttribute('href', url);
      link.setAttribute('download', `export_${entityType}_${timestamp}_enhanced.csv`);
      link.style.visibility = 'hidden';

      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);

      setExportCompleted(`ÿ™ŸÖ ÿ™ÿµÿØŸäÿ± ${filteredData.length} ÿ≥ÿ¨ŸÑ`);
    } catch (error) {
      console.error('Error generating enhanced export:', error);
      alert('ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ŸÅŸä ÿ™ÿµÿØŸäÿ± ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™ ÿ•ŸÑŸâ ÿßŸÑÿ™ŸÜÿ≥ŸäŸÇ ÿßŸÑŸÖÿ≠ÿ≥ŸÜ');
    } finally {
      setIsExporting(false);
    }
  };

  const activeData = exportConfig.includeArchived
    ? data
    : data.filter((item) => !(item as unknown as Record<string, unknown>).isArchived);

  return (
    <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4">
      <Card className="w-full max-w-4xl max-h-[90vh] overflow-y-auto">
        <CardHeader>
          <CardTitle className="text-right flex items-center justify-between">
            <span>{currentConfig.title}</span>
            {onClose && (
              <Button variant="ghost" onClick={onClose} className="p-2">
                ‚úï
              </Button>
            )}
          </CardTitle>
        </CardHeader>

        <CardContent className="space-y-6">
          {/* Export Configuration */}
          <div className="space-y-4">
            <h3 className="text-lg font-medium text-right flex items-center gap-2">
              <Settings className="w-5 h-5" />
              ÿ•ÿπÿØÿßÿØÿßÿ™ ÿßŸÑÿ™ÿµÿØŸäÿ±
            </h3>

            {/* Include Archived Option */}
            <div className="flex items-center gap-2 justify-end">
              <span className="text-sm">ÿ™ÿ∂ŸÖŸäŸÜ ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™ ÿßŸÑŸÖÿ§ÿ±ÿ¥ŸÅÿ©</span>
              <Checkbox
                checked={exportConfig.includeArchived}
                onCheckedChange={(checked) =>
                  setExportConfig(prev => ({ ...prev, includeArchived: !!checked }))
                }
              />
            </div>

            {/* Data Count Display */}
            <div className="bg-blue-50 border border-blue-200 rounded p-3">
              <p className="text-blue-800 text-right">
                ÿπÿØÿØ ÿßŸÑÿ≥ÿ¨ŸÑÿßÿ™ ÿßŸÑŸÖÿ™ÿßÿ≠ÿ© ŸÑŸÑÿ™ÿµÿØŸäÿ±: <strong>{activeData.length}</strong>
                {exportConfig.includeArchived && (
                  <span className="text-sm"> (ÿ¥ÿßŸÖŸÑ ÿßŸÑŸÖÿ§ÿ±ÿ¥ŸÅ)</span>
                )}
              </p>
            </div>
          </div>

          {/* Field Selection */}
          <div className="space-y-4">
            <h3 className="text-lg font-medium text-right">ÿßŸÑÿ≠ŸÇŸàŸÑ ÿßŸÑŸÖÿ∑ŸÑŸàÿ® ÿ™ÿµÿØŸäÿ±Ÿáÿß:</h3>

            <div className="grid grid-cols-1 md:grid-cols-2 gap-3 max-h-60 overflow-y-auto border rounded p-4">
              {currentConfig.availableFields.map((field) => (
                <div key={field.key} className="flex items-center gap-2 justify-end">
                  <span className={`text-sm ${field.required ? 'font-medium' : ''}`}>
                    {field.label}
                    {field.required && <span className="text-red-500"> *</span>}
                  </span>
                  <Checkbox
                    checked={exportConfig.selectedFields.includes(field.key)}
                    onCheckedChange={(checked) => handleFieldToggle(field.key, !!checked)}
                    disabled={field.required}
                  />
                </div>
              ))}
            </div>

            <p className="text-xs text-gray-500 text-right">
              * ÿßŸÑÿ≠ŸÇŸàŸÑ ÿßŸÑŸÖÿ≠ÿØÿØÿ© ŸÖÿ∑ŸÑŸàÿ®ÿ© ŸàŸÑÿß ŸäŸÖŸÉŸÜ ÿ•ŸÑÿ∫ÿßÿ§Ÿáÿß
            </p>
          </div>

          {/* Export Button */}
          <div className="flex justify-center">
            <Button
              onClick={generateComprehensiveExport}
              disabled={isExporting || exportConfig.selectedFields.length === 0}
              className="gap-2 h-auto p-6 flex-col min-w-64"
            >
              <FileSpreadsheet className="w-12 h-12 text-blue-600" />
              <span className="text-xl font-medium">ÿ™ÿµÿØŸäÿ± ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™</span>
              <span className="text-sm text-gray-500">
                ŸÖŸÑŸÅ CSV ÿ¥ÿßŸÖŸÑ ŸÖÿπ ŸÖÿπŸÑŸàŸÖÿßÿ™ ÿ™ŸÅÿµŸäŸÑŸäÿ©
              </span>
              <span className="text-xs text-gray-400">
                ŸäŸÅÿ™ÿ≠ ŸÅŸä Excel Ÿàÿ¨ŸÖŸäÿπ ÿßŸÑÿ®ÿ±ÿßŸÖÿ¨
              </span>
            </Button>
          </div>

          {/* Success Message */}
          {exportCompleted && (
            <Alert className="border-green-500 bg-green-50">
              <Download className="h-4 w-4 text-green-600" />
              <AlertDescription className="text-green-700 text-right">
                ÿ™ŸÖ ÿ™ÿµÿØŸäÿ± ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™ ÿ®ŸÜÿ¨ÿßÿ≠! ({exportCompleted})
              </AlertDescription>
            </Alert>
          )}

          {/* Export Notes */}
          <div className="bg-yellow-50 border border-yellow-200 rounded p-4">
            <h4 className="font-medium text-yellow-800 text-right mb-2">ŸÖŸÑÿßÿ≠ÿ∏ÿßÿ™ ÿßŸÑÿ™ÿµÿØŸäÿ±:</h4>
            <ul className="space-y-1 text-sm text-yellow-700 text-right">
              <li>‚Ä¢ ÿßŸÑŸÖŸÑŸÅÿßÿ™ ÿßŸÑŸÖÿµÿØÿ±ÿ© ÿ™ÿØÿπŸÖ ÿßŸÑŸÜÿµ ÿßŸÑÿπÿ±ÿ®Ÿä ÿ®ÿ™ÿ±ŸÖŸäÿ≤ UTF-8</li>
              <li>‚Ä¢ ÿßŸÑÿ™Ÿàÿßÿ±ŸäÿÆ ÿ®ÿ™ŸÜÿ≥ŸäŸÇ dd-mmm-yyyy ÿ≠ÿ≥ÿ® ŸÖÿπŸäÿßÿ± ÿßŸÑŸÜÿ∏ÿßŸÖ</li>
              <li>‚Ä¢ ÿßŸÑŸÇŸäŸÖ ÿßŸÑŸÖŸÜÿ∑ŸÇŸäÿ© ÿ™ÿ∏Ÿáÿ± ŸÉŸÄ "ŸÜÿπŸÖ" ÿ£Ÿà "ŸÑÿß"</li>
              <li>‚Ä¢ ÿßŸÑŸÖÿµŸÅŸàŸÅÿßÿ™ (ŸÖÿ´ŸÑ ŸÖÿπÿ±ŸÅÿßÿ™ ÿßŸÑÿπŸÇŸàÿØ) ŸÖŸÅÿµŸàŸÑÿ© ÿ®ŸÅÿßÿµŸÑÿ©</li>
              <li>‚Ä¢ ŸäŸÖŸÉŸÜ ŸÅÿ™ÿ≠ ŸÖŸÑŸÅÿßÿ™ CSV ŸÅŸä Excel ŸÖÿ®ÿßÿ¥ÿ±ÿ©</li>
            </ul>
          </div>

          {/* Action Buttons */}
          <div className="flex gap-3 justify-end pt-4 border-t">
            {onClose && (
              <Button variant="outline" onClick={onClose}>
                ÿ•ÿ∫ŸÑÿßŸÇ
              </Button>
            )}
          </div>
        </CardContent>
      </Card>
    </div>
  );
}
